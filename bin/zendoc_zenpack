#!/usr/bin/env python

__doc__ = """zendoc_zenpack

Create an XML file showing the items in the ZenPack.
"""

import os
import os.path
import datetime

import Globals
from Products.ZenUtils.ZenScriptBase import ZenScriptBase
from Products.ZenUtils.Utils import importClass, zenPath
from transaction import commit

class XMLContainer:
    id = ''
    description = ''
    path = ''
    meta_type = ''

    def __init__(self, id='', meta_type=''):
        self.id = id
        self.meta_type = meta_type

    def getPrimaryPath(self):
        return self.path

threshie = XMLContainer('threshold', 'ThresholdContainer')
plugin_container = XMLContainer('modeler_plugin_container',
                                'ModelerPluginContainer')

class ModelerPlugin:
    id = ''
    description = ''
    path = ''
    meta_type = 'ModelerPlugin'

    def getPrimaryPath(self):
        return self.path.split('/')


def print_xml_tree(tree, indent=0):
    if '__id' in tree:
        header = " " * indent + """<%(__meta_type)s id="%(__id)s" location="%(__location)s" """ % tree
        if '__class' in tree and tree['__class']:
            header += 'class="%s"' % tree['__class']
        if '__hasTransform' in tree:
            header += ' hasTransform="%s"' % tree['__hasTransform']
        print header + " >"
        desc = tree['__description']
        if desc:
            print " " * indent + """<![CDATA[%s]]>""" % desc

    for obj in sorted(tree.keys()):
        if obj.startswith('__'): continue
        print_xml_tree(tree[obj], indent + 1 )

    if '__id' in tree:
        print " " * indent + "</%(__meta_type)s>" % tree

def add_object(root, obj):
    root['__id'] = obj.id
    root['__description'] = obj.description
    root['__location'] = '/'.join(obj.getPrimaryPath())
    root['__meta_type'] = obj.meta_type
    root['__class'] = obj.__class__.__name__
    if obj.__class__.__name__ == 'EventClass':
        if obj.transform:
            root['__hasTransform'] = 'yes'
        else:
            root['__hasTransform'] = 'no'

def get_modeler_description(path, file):
    location = path.replace(zenPath(), '')
    # Start from the ZenPack location
    location = location.split('/')[3:]
    name = file.replace('.py', '')
    location.append(name)
    location = '.'.join(location)
    # Location will be something like 
    # ZenPacks.zenoss.AixMonitor.modeler.plugins.zenoss.cmd.aix.netstat_na
    try:
        mod = __import__(location, globals(), locals(), name)
        desc = mod.__doc__
    except:
        desc = 'Unable to load plugin %s' % location
    return desc

def add_plugin(root, file, path):
    plugin = ModelerPlugin()
    plugin.id = file.replace('.py', '')
    plugin.path = path
    plugin.description = get_modeler_description(path, file)
    add_object(root, plugin)

def modelerSearch(root, zp):
    plugin_dir = os.path.join(zp.path(), 'modeler', 'plugins')
    if not os.path.exists(plugin_dir):
        return
    
    # Yes, you're right -- the following should be equivalent
    # root = root['']['zport']['dmd']
    #  But it's not.  Move along.
    for loc in root:  # Dereference ''
        root = root[loc]
    for loc in root:  # Dereference 'zport'
        root = root[loc]
    for loc in root:  # Dereference 'dmd'
        root = root[loc]
    # Back to sanity. Yay!
    madeOrganizer = False
    for path, unused, files in os.walk(plugin_dir):
        for file in files:
            if not file.endswith('.py') or file == '__init__.py':
                continue
            if not madeOrganizer:
                root['Modelers'] = {}
                new_root = root['Modelers']
                add_object(new_root, plugin_container)
                madeOrganizer = True
            new_root[file] = {}
            add_plugin(new_root[file], file, path)


def zenpack2XML(dmd, zp):
    dependencies = ', '.join( [' '.join([x,y]) for x, y in sorted(zp.dependencies.items()) ] )
    print "<zenpack id='%s' version='%s' author='%s' dependencies='%s' >" % (
          zp.id, zp.version, zp.author, dependencies)

    # Since the packables aren't arranged hierarchically,
    # we need to build our own tree.
    tree = {}
    for obj in zp.packables():
        root = tree
        obj_path = obj.getPrimaryPath()
        for i, loc in enumerate(obj_path):
            if loc not in root:
                root[loc] = {}
                # Graphs don't have their own node
                if i > 0 and  obj_path[i-1] == 'graphDefs':
                    graph_path = '/'.join(obj_path[:i+1])
                    graph_obj = dmd.getObjByPath(graph_path)
                    add_object(root[loc], graph_obj)

                # Thresholds don't have a container
                if loc == 'thresholds':
                    add_object(root[loc], threshie)

            root = root[loc]
        add_object(root, obj)
    modelerSearch(tree, zp)

    # Print out the tree
    print_xml_tree(tree)

    print "</zenpack>"


def xml_header():
    export_date = datetime.datetime.now()
    print """<?xml version="1.0" encoding="UTF-8"?>

<!-- ZenPack information generated on %s -->
<zenpacks >
""" % (export_date) 

def xml_trailer():
    print """
</zenpacks>
"""


if __name__ == '__main__':
    xml_header()
    dmd = ZenScriptBase(connect=True).dmd
    for zp in dmd.ZenPackManager.packs():
        zenpack2XML(dmd, zp)
    xml_trailer()
