import socket
import logging

from twisted.internet import reactor, error
from twisted.python import failure
from twistedsnmp import snmpprotocol, agentproxy

import Globals

from Products.ZenUtils.IpUtil import isip

global defaultTries, defaultTimeout
defaultTries = 2
defaultTimeout = 1

class SnmpClient(object):

    def __init__(self, hostname, port=161, community="public", snmpver="v2", 
                options=None, device=None, datacollector=None, 
                log=None, plugins=[]):
        global defaultTries, defaultTimeout
        self.hostname = hostname
        self.device = device
        self.options = options
        self.datacollector = datacollector
        self.plugins = plugins

        self.queries = 0
        self._getdata = {}
        self._tabledata = {}

        if options:
            defaultTries = options.loginTries
            defaultTimeout = options.loginTimeout

        community = getattr(device, 'zSnmpCommunity', community)
        port = int(getattr(device, 'zSnmpPort', port))
        tries = getattr(device,'zSnmpTries', defaultTries)
        timeout = getattr(device,'zSnmpTimeout', defaultTimeout)

        if device:
            ipaddr = device.getManageIp()
        else:
            ipaddr = socket.gethostbyname(hostname)
        if log:
            self.log = log
        else:
            self.log = logging.getLogger("SnmpClient")
        srcport = snmpprotocol.port()
        self.proxy = agentproxy.AgentProxy(ipaddr, port, community, snmpver,
                                           protocol=srcport.protocol)
        self.log.info("device %s proxy %s", self.hostname, self.proxy)
        #reactor.callWhenRunning(self._sendQueries)
        self._sendQueries()


    def _sendQueries(self):
        for plugin in self.plugins:
            pname = plugin.name()
            self.log.debug("sending queries for plugin %s", pname)
            if plugin.snmpGetMap:
                d = self.proxy.get(plugin.snmpGetMap.getoids())
                self.queries +=1
                d.addCallback(self._snmpGetCallback, pname)
                d.addErrback(self._handleError, pname)
            for tmap in plugin.snmpGetTableMaps:
                d = self.proxy.getTable(tmap.getoids()) 
                self.queries +=1
                d.addCallback(self._snmpGetTableCallback, pname, tmap)
                d.addErrback( self._handleError, pname)


    def _snmpGetCallback(self, results, pluginName):
        self.log.debug("received plugin:%s getOids", pluginName)
        self.queries -=1
        self._getdata[pluginName] = results 
        self.clientFinished()
   

    def _snmpGetTableCallback(self, results, pluginName, tmap):
        self.log.debug("received plugin:%s table:%s", pluginName, tmap.name)
        self.queries -=1
        pdata = self._tabledata.setdefault(pluginName, {})
        pdata[tmap] = results
        self.clientFinished()


    def _handleError( self, err, pname):
        """Handle an error generated by one of our requests.
        """
        self.queries -=1
        self.log.debug('device %s plugin %s %s', self.hostname, pname, err )
        if isinstance( err, failure.Failure ):
            actualError = err.value
            trace = err.getTraceback()
        else:
            actualError = err
            trace = self.log.getException( err )
        if not isinstance( actualError, error.TimeoutError ):
            self.log.error(
                """device %s plugin %s unexpected error: %s""",
                self.hostname, pname, trace,
            )
        self.clientFinished()
        return None


    def getResults(self):
        """Return data for this client in the form
        ((pname, (getdata, tabledata),)
        getdata = {'.1.2.4.5':"value",}
        tabledata = {tableMap : {'.1.2.3.4' : {'.1.2.3.4.1': "value",...}}} 
        """
        data = []
        for plugin in self.plugins:
            pname = plugin.name()
            data.append((pname, (self._getdata.get(pname,{}),
                                 self._tabledata.get(pname,{}))
                       ))
        return data 


    def clientFinished(self):
        """tell the datacollector that we are all done"""
        if self.queries != 0: return
        self.log.info("snmp client finished collection for %s" % self.hostname)
        if self.datacollector:
            self.datacollector.clientFinished(self)
        else:
            reactor.stop()



def buildOptions(parser=None, usage=None):
    "build options list that both telnet and ssh use"
   
    if not usage:
        usage = "%prog [options] hostname[:port] oids"

    if not parser:
        from optparse import OptionParser
        parser = OptionParser(usage=usage, 
                                   version="%prog " + __version__)
  
    parser.add_option('--snmpCommunity',
                dest='snmpCommunity',
                default=defaultSnmpCommunity,
                help='Snmp Community string')


if __name__ == "__main__":
    import pprint
    logging.basicConfig()
    log = logging.getLogger()
    log.setLevel(20)
    import sys
    sys.path.append("plugins")
    from plugins.zentinel.snmp.InterfaceMap import InterfaceMap
    ifmap = InterfaceMap()
    sc = SnmpClient("gate.confmon.loc", community="zentinel", plugins=[ifmap,])
    reactor.run()
    pprint.pprint(sc.getResults())
